# 计算属性和监听器
## 模板
```js
var app = new Vue({
    el:'#example',
    data:{
        massage:'hello'
        },
    computed:{
    //计算属性的getter
    reversedMessage:function(){
        //this指向vm实例
        return this.message.split('').reverse().join('')
        }
    }
})
```
```html
<div id="example"> 
    <p>Original message: "{{ message }}"</p> 
    <p>Computed reversed message: "{{ reversedMessage }}"</p> 
</div>
```

结果：
Original message: "Hello"
Computed reversed message: "olleH"

## 计算属性缓存 VS 方法
同样的效果可以通过在表达式中调用方法来实现:`{{<p>Reversed message: "{{ reversedMessage() }}"</p>}}`
```js
// 在组件中 
methods: { 
    reversedMessage: function () { 
        return this.message.split('').reverse().join('') 
    } 
}
```
**虽然两种方式的最终结果是完全相同的**然而，**不同的是计算属性是基于它们的响应式依赖进行缓存的**。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。

我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！**如果你不希望有缓存，请用方法来替代**。

## 侦听器
`watch`选项提供了一个更通用的方法, 来响应数据的变化. 当需要在数据变化时执行异步或开销比较大的操作时, 这个方式最有用.watch需要设置防抖.

```js
new Vue({
    el:'#app'
})
```



## 计算属性 VS 侦听属性

Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：**侦听属性**。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 `watch`——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的`watch` 回调。

## 计算属性的setter
计算属性有`getter`和`setter`, 即获取数据的函数和回调数据的函数
```js
computed:{
    fullName:{
    //getter
    get: function(){
        return this.firstName + ' ' + this.lastName
    },
    set: function(newValue){
        var names = newValue.split(` `)
        this.firstName = names[0]
        this.lastName = names[names.length - 1]
    }
    }
}
```
现在再运行`vm.fullName = "John Doe"`时,setter会被调用,`vm.firstName`和`vm.lastName`也会相应的被更新